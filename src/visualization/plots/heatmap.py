from pathlib import Path
from typing import Optional, Union, List
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from typing import Dict
from types import FunctionType
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent.parent))
from visualization.core.base_plot import BasePlot
from visualization.utils.validation import validate_input_data
from visualization.config.plot_config import HeatmapConfig

class EEGHeatmapPlot(BasePlot):
    """EEG Heatmap visualization with anatomical regions
    
    Attributes:
        data: Input DataFrame containing EEG data
        config: HeatmapConfig object with plot settings
        metrics: Statistical metric to use ('mean' or 't_stat')
    """
    
    def __init__(self,
                 data: Union[pd.DataFrame, Path],
                 stats_func: FunctionType,
                 stats_kwargs: Dict[str,str],
                 config: Optional[HeatmapConfig] = None,
                 stats_attribute: Optional[str] = None,
                 ):
        """Initialization

        Args:
            data (Union[pd.DataFrame, Path]): _description_
            stats_func (FunctionType): The function to pass for aggregation.
            stats_kwargs (Dict[str,str]): The key-word arguments to pass for the
                                          aggregation function
            stats_attribute (Optional[str]): The attribute from the object
                                             generated by the stats_func
                                             such as `statistics` when 
                                             `scipy.stats.ttest_1samp` is passed
                                             as a stats_function.
            config (Optional[HeatmapConfig], optional): The config object of
                                                        the plot if necessary.
        """
        self.data = validate_input_data(data)
        self.config = config or HeatmapConfig()
        self.stats_func = stats_func
        self.stats_kwargs = stats_kwargs
        self.stats_attribute = stats_attribute
        super().__init__(self.data, Path('figures'))

    def prepare_data(self, **kwargs) -> pd.DataFrame:
        """Prepare and pivot data for heatmap plotting"""
        func = self._get_stat_function()
        cap_data = self.data[self.data["ts_CAPS"] == kwargs["cap"]]
        return cap_data.pivot_table(
            index='ch_name',
            columns='frequency_Hz',
            values='pearson_r',
            aggfunc=func
        )

    def _get_stat_function(self):
        """Get the appropriate stat_function function"""
        if self.stats_attribute is None:
            return lambda x: self.stats_func(x, **self.stats_kwargs)
        else:
            return lambda x: getattr(self.stats_func(x, **self.stats_kwargs),
                                     self.stats_attribute)
        
    def create_plot(self, caps: Optional[List[str]] = None) -> None:
        """Create multi-panel heatmap plot
        
        Args:
            caps: List of CAP values to plot. If None, uses all unique values
        """
        caps = caps or self.data['ts_CAPS'].unique()
        n_rows = 2
        n_cols = len(caps) // n_rows
        
        self.fig, axes = plt.subplots(n_rows, n_cols, 
                                     figsize = self.config.figsize,
                                     sharex=True)
        
        for ax, cap in zip(axes.flatten(), caps):
            if cap == "CAP1":
                anatomy_labels = True
            else: 
                anatomy_labels = False
            if cap == "CAP8":
                cbar_kws = {"label": f"{self.stats_func.__name__} values"}
            else:
                cbar_kws = None

            self._plot_single_cap(ax, cap, anatomy_labels=anatomy_labels,
                                  cbar = True,cbar_kws = cbar_kws)
            
        self.fig.tight_layout()

    def _plot_single_cap(self, ax: plt.Axes, cap: str, anatomy_labels: bool = False,
                         **heatmap_args) -> None:
        """Plot heatmap for a single CAP value"""
        cap_data = self.prepare_data(cap = cap)
        
        # Sort anatomical regions
        sorted_data, anatomy_info = self._sort_anatomical_data(cap_data)
        
        # Create heatmap
        sns.heatmap(
            sorted_data,
            cmap=self.config.cmap,
            vmin=self.config.vmin,
            vmax=self.config.vmax,
            linewidths=self.config.linewidths,
            ax=ax,
            **heatmap_args
        )
        
        # Add anatomical separators
        self._add_anatomical_separators(ax, anatomy_info)
        
        if anatomy_labels:
            self._add_anatomy_labels(ax=ax, anatomy_info=anatomy_info)
        
        # Customize appearance
        self._customize_axis(ax, cap)

    def _sort_anatomical_data(self, data) -> tuple[pd.DataFrame, pd.DataFrame]:
        """Sort data by anatomical regions.
        Returns:
            tuple containing:
            - sorted_data: DataFrame with data sorted by anatomical regions
            - anatomy_info: DataFrame with anatomy grouping information
        """
    
        # Get channel-to-anatomy mapping
        cap_info = self.data[['ch_name', 'anatomy']]
        anatomy_mapping = cap_info.drop_duplicates().set_index('ch_name')
    
        # Sort data by anatomical regions
        data = data.loc[anatomy_mapping.index]
        anatomy_info = anatomy_mapping.loc[
            anatomy_mapping['anatomy']
            .astype('category')
            .cat.set_categories(self.config.anatomical_order, ordered=True)
            .sort_values()
            .index
        ]
    
        sorted_data = data.loc[anatomy_info.index]
    
        return sorted_data, anatomy_info

    def _add_anatomical_separators(self, ax: plt.Axes, anatomy_info: pd.DataFrame) -> None:
        """Add separator lines and labels for anatomical regions
    
        Args:
            ax: Matplotlib axis object to add separators to
            anatomy_info: DataFrame containing channel to anatomy mapping info
        """
        # Get indices where anatomy changes
        anatomy_changes = np.where(anatomy_info['anatomy'].values[1:] != 
                                 anatomy_info['anatomy'].values[:-1])[0]
    
        # Add horizontal lines at anatomy boundaries
        for idx in anatomy_changes:
            ax.axhline(y=idx + 1, color='white', linewidth=2)
    
    def _add_anatomy_labels(self, ax: plt.Axes, anatomy_info: pd.DataFrame) -> None:
        # Add anatomy labels
        anatomy_changes = np.where(anatomy_info['anatomy'].values[1:] != 
                                 anatomy_info['anatomy'].values[:-1])[0]
        anatomy_changes = np.append(anatomy_changes, len(anatomy_info))
        unique_anatomies = anatomy_info['anatomy'].unique()
        color_palette = sns.diverging_palette(
            150, 
            40, 
            l=50, 
            center="dark",
            n=len(self.config.anatomical_order)
            )

        anatomy_colors = dict(zip(self.config.anatomical_order, color_palette))
        
        # Force exact positioning by using transform coordinates

        for i, anatomy in enumerate(unique_anatomies):
            # Calculate exact middle position
            if i == 0:
                middle = anatomy_changes[i] / 2
            else:
                middle = (anatomy_changes[i-1] + anatomy_changes[i]) / 2

            # Use transform to maintain exact float coordinates
            ax.text(-0.15, middle, 
                    anatomy.capitalize(),
                    rotation=0,
                    color=anatomy_colors[anatomy],
                    va='center',
                    ha='right',
            ) 

    def _customize_axis(self, ax: plt.Axes, title: str) -> None:
        """Customize axis appearance"""
        ax.set_title(title)
        ax.set_ylabel('')
        ax.set_yticks([])
        if title != "CAP8":  # Only show xlabel for bottom row
            ax.set_xlabel('')
