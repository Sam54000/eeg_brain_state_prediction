from pathlib import Path
from typing import Optional, Union, List
import numpy as np
import pandas as pd
from matplotlib.backends.backend_pdf import PdfPages
import seaborn as sns
import matplotlib.pyplot as plt
from typing import Dict
from types import FunctionType
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent.parent))
from visualization.core.base_plot import BasePlot
from visualization.utils.validation import validate_input_data
from visualization.config.plot_config import HeatmapConfig

class EEGHeatmapPlot(BasePlot):
    """EEG Heatmap visualization with anatomical regions
    
    Attributes:
        data: Input DataFrame containing EEG data
        config: HeatmapConfig object with plot settings
        metrics: Statistical metric to use ('mean' or 't_stat')
    """
    
    def __init__(self,
                 data: Union[pd.DataFrame, Path],
                 stats_func: FunctionType,
                 stats_kwargs: Dict[str,str],
                 config: Optional[HeatmapConfig] = None,
                 stats_attribute: Optional[str] = None,
                 ):
        """Initialization

        Args:
            data (Union[pd.DataFrame, Path]): _description_
            stats_func (FunctionType): The function to pass for aggregation.
            stats_kwargs (Dict[str,str]): The key-word arguments to pass for the
                                          aggregation function
            stats_attribute (Optional[str]): The attribute from the object
                                             generated by the stats_func
                                             such as `statistics` when 
                                             `scipy.stats.ttest_1samp` is passed
                                             as a stats_function.
            config (Optional[HeatmapConfig], optional): The config object of
                                                        the plot if necessary.
        """
        self.data = validate_input_data(data)
        self.config = config or HeatmapConfig()
        self.stats_func = stats_func
        self.stats_kwargs = stats_kwargs
        self.stats_attribute = stats_attribute
        super().__init__(self.data)
    
    def get_cap_frequency_pairs(self, **kwargs) -> pd.DataFrame:
        """Prepare and pivot data for heatmap plotting"""
        
        boolean_selection = []
        for key, value in kwargs.items():
            boolean_selection.append(self.data[key] == value)
        
        boolean_selection = np.all(np.stack(boolean_selection), axis = 0)
        selected_data = self.data[boolean_selection]
        if kwargs.get('subject', False):
            func = "mean"
        else:
            func = self._get_stat_function()

        return selected_data.pivot_table(
            index='ch_name',
            columns='frequency_Hz',
            values='pearson_r',
            aggfunc=func
        )

    def _get_stat_function(self):
        """Get the appropriate stat_function function"""
        if self.stats_attribute is None:
            return lambda x: self.stats_func(x, **self.stats_kwargs)
        else:
            return lambda x: getattr(self.stats_func(x, **self.stats_kwargs),
                                     self.stats_attribute)
        
    def _plot_population_level(self, 
                                caps: Optional[List[str]] = None
                                ) -> None:
        """Create multi-panel heatmap plot
        
        Args:
            caps: List of CAP values to plot. If None, uses all unique values
        """
        caps = caps or self.data['ts_CAPS'].unique()
        n_rows = 2
        n_cols = len(caps) // n_rows
        
        self.fig, axes = plt.subplots(n_rows, n_cols, 
                                     figsize = self.config.figsize,
                                     sharex=True)
        
        for ax, cap in zip(axes.flatten(), caps):
            if cap == "CAP1":
                anatomy_labels = True
            else: 
                anatomy_labels = False
            if cap == "CAP8":
                cbar_kws = {"label": f"{self.stats_func.__name__} values"}
            else:
                cbar_kws = None

            selection = self.get_cap_frequency_pairs(
                ts_CAPS = cap
            )
            self._plot_single_cap(
                selection = selection,
                ax = ax, 
                anatomy_labels=anatomy_labels,
                chan_labels=False,
                cbar = True,
                cbar_kws = cbar_kws
            )
            ax.set_ylabel('')
            ax.set_yticks([])

        self.fig.tight_layout()
    
    def _plot_subject_level(self):
        self.config.ylabel = ""
        self.config.xlabel = "Frequency (Hz)"
        with PdfPages(self.config.output_filename) as pdf:
            for subject in self.data['subject'].unique():
                for cap in self.data['ts_CAPS'].unique():
                    self.fig, ax = plt.subplots(figsize=self.config.figsize)
                    self.fig.subplots_adjust(**self.config.layout_args)
                    
                    selection = self.get_cap_frequency_pairs(
                        subject=subject,
                        ts_CAPS=cap
                    )
                    self._plot_single_cap(
                        selection,
                        ax,
                        anatomy_labels=True,
                        chan_labels=True,
                        cbar=True,
                        cbar_kws={"label": "Pearson's R"}
                    )
                    
                    ax.set_ylabel('')
                    ax.set_xlabel("Frequency (Hz)")
                    ax.set_title(f"sub-{subject} {cap}")
                    pdf.savefig(self.fig)
                    plt.close(self.fig)
                    

    def create_plot(self, level = "subject"):
        """Main function to create the plot

        Args:
            level (str, optional): The level to plot the heatmap can be at the
                                   subject level (Default) or at the population
                                   level.
        """
        if level == "subject":
            self._plot_subject_level()
        else:
            self._plot_population_level()



    def _plot_single_cap(self, 
                         selection: pd.DataFrame,
                         ax: plt.Axes, 
                         anatomy_labels: bool = False,
                         chan_labels: bool = True,
                         **heatmap_args) -> None:
        """Plot heatmap for a single CAP value"""
        
        # Sort anatomical regions
        sorted_data, anatomy_info = self._sort_anatomical_data(selection)
        
        # Create heatmap
        sns.heatmap(
            sorted_data,
            cmap=self.config.cmap,
            vmin=self.config.vmin,
            vmax=self.config.vmax,
            linewidths=self.config.linewidths,
            ax=ax,
            **heatmap_args
        )
        
        # Add anatomical separators
        self._add_anatomical_separators(ax, anatomy_info)
        
        if chan_labels:
            ax.set_yticklabels(list(sorted_data.index))
            self._add_channel_names(ax=ax)

        if anatomy_labels:
            if chan_labels:
                xpos = -2.2
            else:
                xpos = -0.15

            self._add_anatomy_labels(ax=ax, anatomy_info=anatomy_info,xpos=xpos)
        
    def _sort_anatomical_data(self, data) -> tuple[pd.DataFrame, pd.DataFrame]:
        """Sort data by anatomical regions.
        Returns:
            tuple containing:
            - sorted_data: DataFrame with data sorted by anatomical regions
            - anatomy_info: DataFrame with anatomy grouping information
        """
    
        # Get channel-to-anatomy mapping
        cap_info = self.data[['ch_name', 'anatomy']]
        anatomy_mapping = cap_info.drop_duplicates().set_index('ch_name')
    
        # Sort data by anatomical regions
        data = data.loc[anatomy_mapping.index]
        anatomy_info = anatomy_mapping.loc[
            anatomy_mapping['anatomy']
            .astype('category')
            .cat.set_categories(self.config.anatomical_order, ordered=True)
            .sort_values()
            .index
        ]
    
        sorted_data = data.loc[anatomy_info.index]
    
        return sorted_data, anatomy_info

    def _add_anatomical_separators(self, ax: plt.Axes, anatomy_info: pd.DataFrame) -> None:
        """Add separator lines and labels for anatomical regions
    
        Args:
            ax: Matplotlib axis object to add separators to
            anatomy_info: DataFrame containing channel to anatomy mapping info
        """
        # Get indices where anatomy changes
        anatomy_changes = np.where(anatomy_info['anatomy'].values[1:] != 
                                 anatomy_info['anatomy'].values[:-1])[0]
    
        # Add horizontal lines at anatomy boundaries
        for idx in anatomy_changes:
            ax.axhline(y=idx + 1, **self.config.anat_sep_args)
                       
    
    def _add_channel_names(self, ax:plt.Axes,):
        anatomy_to_channels = self.data.groupby('anatomy')['ch_name']\
            .unique().reindex(self.config.anatomical_order)
        if ax is not None:
            for label in ax.get_yticklabels():
                channel_name = label.get_text()
                for anatomy, channels in anatomy_to_channels.items():
                    if channel_name in channels:
                        label.set_color(
                            self.config.anatomy_colors[anatomy]
                            )
                        break
    
    def _add_anatomy_labels(self, ax: plt.Axes, anatomy_info: pd.DataFrame,
                            xpos: float) -> None:
        # Add anatomy labels
        anatomy_changes = np.where(anatomy_info['anatomy'].values[1:] != 
                                 anatomy_info['anatomy'].values[:-1])[0]
        anatomy_changes = np.append(anatomy_changes, len(anatomy_info))
        unique_anatomies = anatomy_info['anatomy'].unique()
        
        # Force exact positioning by using transform coordinates

        for i, anatomy in enumerate(unique_anatomies):
            # Calculate exact middle position
            if i == 0:
                middle = anatomy_changes[i] / 2
            else:
                middle = (anatomy_changes[i-1] + anatomy_changes[i]) / 2

            # Use transform to maintain exact float coordinates
            ax.text(xpos, 
                    middle, 
                    anatomy.capitalize(),
                    rotation=0,
                    color=self.config.anatomy_colors[anatomy],
                    va='center',
                    ha='right',
                    fontdict={
                        "size": 12,
                        "fontweight": "bold"
                    }
            ) 

    def preview_single_plot(self, subject: str, cap: str, chan_labels: bool = True) -> None:
        """Preview a single plot for a specific subject and CAP
        
        Args:
            subject: Subject ID to plot
            cap: CAP value to plot
        """
        self.fig, ax = plt.subplots(figsize=self.config.figsize)
        self.fig.subplots_adjust(**self.config.layout_args)
        
        selection = self.get_cap_frequency_pairs(
            subject=subject,
            ts_CAPS=cap
        )
        
        self._plot_single_cap(
            selection,
            ax,
            anatomy_labels=True,
            chan_labels=chan_labels,
            cbar=True,
            cbar_kws={"label": "Pearson's R"}
        )
        
        ax.set_ylabel('')
        ax.set_title(f"sub-{subject} {cap}")
        plt.show()  # This will display the plot instead of saving it